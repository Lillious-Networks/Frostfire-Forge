name: Production > Release

permissions:
  contents: write

on:
  workflow_dispatch:
  push:
    paths:
      - 'src/**'
      - 'docker-compose.prod.yml'
      - 'Dockerfile.prod'
      - '.github/workflows/production_release.yml'
    branches:
      - main

concurrency:
  group: 'production-release'
  cancel-in-progress: true

jobs:
    create_release_number:
        name: Create Release Number
        uses: ./.github/workflows/generate_release_number.yml
        # output: release-number

    build:
      name: Build v${{ needs.create_release_number.outputs.release-number }}
      needs: [create_release_number]
      runs-on: self-hosted
      environment: production
      steps:
        - name: Checkout Repository
          uses: actions/checkout@v4

        - name: Update environment variables
          run: |
            # Check if .env.production is a directory (should not be)
            if [ -d ".env.production" ]; then
              echo ".env.production is a directory. Removing it."
              rm -rf .env.production
            fi

            # Remove existing .env.production file if it exists and is not a directory
            if [ -f ".env.production" ]; then
              echo ".env.production file exists. Removing it."
              rm .env.production
            fi

            echo 'DATABASE_ENGINE=mysql' >> .env.production
            echo 'DATABASE_HOST="${{ secrets.DATABASE_HOST }}"' >> .env.production
            echo 'DATABASE_NAME="${{ secrets.DATABASE_NAME }}"' >> .env.production
            echo 'DATABASE_PASSWORD="${{ secrets.DATABASE_PASSWORD }}"' >> .env.production
            echo 'DATABASE_USER="${{ secrets.DATABASE_USER }}"' >> .env.production
            echo 'DATABASE_PORT="${{ secrets.DATABASE_PORT }}"' >> .env.production
            echo 'EMAIL_PASSWORD="${{ secrets.EMAIL_PASSWORD }}"' >> .env.production
            echo 'EMAIL_SERVICE="${{ secrets.EMAIL_SERVICE }}"' >> .env.production
            echo 'EMAIL_USER="${{ secrets.EMAIL_USER }}"' >> .env.production
            echo 'EMAIL_TEST="${{ secrets.EMAIL_TEST }}"' >> .env.production
            echo 'SESSION_KEY="${{ secrets.SESSION_KEY }}"' >> .env.production
            echo 'SQL_SSL_MODE=DISABLED' >> .env.production
            echo 'WEBSRV_PORT=80' >> .env.production
            echo 'WEBSRV_PORTSSL=443' >> .env.production
            echo 'WEBSRV_USESSL=true' >> .env.production
            echo 'GOOGLE_TRANSLATE_API_KEY="${{ secrets.GOOGLE_TRANSLATE_API_KEY }}"' >> .env.production
            echo 'OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}"' >> .env.production
            echo 'TRANSLATION_SERVICE="openai"' >> .env.production
            echo 'OPEN_AI_MODEL="gpt-4.1-nano-2025-04-14"' >> .env.production
            echo 'WEB_SOCKET_URL="wss://forge.lillious.com"' >> .env.production
            echo 'WEB_SOCKET_PORT=3000' >> .env.production
            echo 'DOMAIN="https://forge.lillious.com"' >> .env.production
            echo 'GAME_NAME="Frostfire Forge"' >> .env.production
            echo 'CACHE="memory"' >> .env.production
            echo 'REDIS_URL="redis://default:${{ secrets.REDIS_PASSWORD }}@redis:6379"' >> .env.production
            echo 'REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"' >> .env.production
            echo 'VERSION="${{ needs.create_release_number.outputs.release-number }}"' >> .env.production

        - name: Create Certificate Chain
          working-directory: src/certs
          run: |
            # Create CA Bundle using CERT_CA_BUNDLE secret
            echo "${{ secrets.CERT_CA_BUNDLE }}" > cert.ca-bundle

            # Create pem
            echo "${{ secrets.CERT_PEM }}" > cert.pem

            # Create private key
            echo "${{ secrets.CERT_PRIVATE_KEY }}" > key.pem

        - name: Build Docker Image
          run: |
            export REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
            docker compose -f docker-compose.prod.yml build

    backup-docker-images:
      name: Backup Current Docker Images
      runs-on: self-hosted
      environment: production
      needs: [build]
      steps:
        - name: Tag current images as backup
          run: |
            # Get list of running containers and their images
            RUNNING_IMAGES=$(docker compose -f docker-compose.prod.yml ps --format json | jq -r '.Image' 2>/dev/null || echo "")

            if [ -n "$RUNNING_IMAGES" ]; then
              echo "Backing up current Docker images..."
              # Remove duplicates and filter out SHA256 hashes
              UNIQUE_IMAGES=$(echo "$RUNNING_IMAGES" | sort -u | grep -v "^sha256:")

              while IFS= read -r image; do
                if [ -n "$image" ] && [ "$image" != "sha256:"* ]; then
                  # Tag each running image with a backup suffix
                  echo "Tagging $image as ${image}-backup"
                  docker tag "$image" "${image}-backup" || echo "Failed to tag $image, might not exist"
                fi
              done <<< "$UNIQUE_IMAGES"
            else
              echo "No running containers found to backup"
            fi

    stop-docker-containers:
      name: Stop Existing Docker Containers
      runs-on: self-hosted
      environment: production
      needs: [backup-docker-images]
      steps:
        - name: Stop Docker Container
          run: |
            docker compose -f docker-compose.prod.yml down || echo "No container to stop"

    start-docker-container:
      name: Start Docker Container
      runs-on: self-hosted
      environment: production
      needs: [stop-docker-containers]
      steps:
        - name: Start Docker Services
          run: |
            export REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
            docker compose -f docker-compose.prod.yml up -d

    verify-docker-container:
      name: Verify Docker Container is Running
      runs-on: self-hosted
      environment: production
      needs: [start-docker-container]
      outputs:
        status: ${{ steps.verify.outcome }}
      steps:
        - name: Wait for services and check logs
          id: verify
          continue-on-error: true
          run: |
            echo "Waiting 15 seconds for services to start..."
            sleep 15

            echo "Fetching Docker logs..."
            LOGS=$(docker compose -f docker-compose.prod.yml logs --tail=50)

            echo "$LOGS"

            if echo "$LOGS" | grep -q "Webserver started"; then
              echo "✅ Webserver started successfully"
              exit 0
            else
              echo "❌ Webserver did NOT start"
              exit 1
            fi

        - name: Check verification result
          if: steps.verify.outcome == 'failure'
          run: |
            echo "Verification failed, triggering rollback..."
            exit 1

    rollback:
      name: Rollback to Previous Docker Images
      runs-on: self-hosted
      environment: production
      needs: [verify-docker-container]
      if: failure() && needs.verify-docker-container.outputs.status == 'failure'
      steps:
        - name: Checkout Repository
          uses: actions/checkout@v4

        - name: Stop failed containers
          run: |
            echo "Stopping failed Docker containers..."
            docker compose -f docker-compose.prod.yml down || echo "No containers to stop"

        - name: Restore backup images
          run: |
            echo "Restoring backup Docker images..."

            # Find all backup images
            BACKUP_IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -- "-backup$" || echo "")

            if [ -n "$BACKUP_IMAGES" ]; then
              while IFS= read -r backup_image; do
                if [ -n "$backup_image" ]; then
                  # Remove -backup suffix to get original image name
                  original_image="${backup_image%-backup}"
                  echo "Restoring $backup_image to $original_image"

                  # Remove the new (failed) image if it exists
                  docker rmi "$original_image" 2>/dev/null || echo "No new image to remove"

                  # Re-tag backup image to original name
                  docker tag "$backup_image" "$original_image"
                fi
              done <<< "$BACKUP_IMAGES"
            else
              echo "No backup images found to restore"
              exit 1
            fi

        - name: Start containers with backup images
          run: |
            echo "Starting Docker containers with backup images..."
            export REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
            docker compose -f docker-compose.prod.yml up -d

        - name: Verify rollback
          run: |
            echo "Waiting 15 seconds for services to start..."
            sleep 15

            echo "Fetching Docker logs..."
            LOGS=$(docker compose -f docker-compose.prod.yml logs --tail=50)

            echo "$LOGS"

            if echo "$LOGS" | grep -q "Webserver started"; then
              echo "✅ Rollback successful - Previous version is running"
            else
              echo "❌ Rollback failed - Manual intervention required"
              exit 1
            fi

    cleanup:
      name: Cleanup Old Docker Images
      runs-on: self-hosted
      environment: production
      needs: [start-docker-container, verify-docker-container]
      if: success() && needs.verify-docker-container.outputs.status == 'success'
      steps:
        - name: Remove Backup and Unused Docker Images
          run: |
            echo "Removing backup Docker images..."
            # Remove all backup images
            BACKUP_IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -- "-backup$" || echo "")

            if [ -n "$BACKUP_IMAGES" ]; then
              while IFS= read -r backup_image; do
                if [ -n "$backup_image" ]; then
                  echo "Removing backup image: $backup_image"
                  docker rmi "$backup_image" || echo "Failed to remove $backup_image"
                fi
              done <<< "$BACKUP_IMAGES"
            else
              echo "No backup images found"
            fi

            echo "Removing unused Docker images..."
            docker image prune -f

    create_release_tag:
        name: Create Release Tag
        runs-on: ubuntu-latest
        needs: [create_release_number, build, verify-docker-container]
        steps:
        - name: Create Git Tag
          env:
              GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              RELEASE_NUMBER: ${{ needs.create_release_number.outputs.release-number }}
          run: |
              SHA=$(gh api repos/${{ github.repository }}/git/ref/heads/${{ github.ref_name }} --jq '.object.sha')
              gh api repos/${{ github.repository }}/git/refs \
              -f ref="refs/tags/${RELEASE_NUMBER}" \
              -f sha="$SHA"

    create_github_release:
        needs: [create_release_number, create_release_tag]
        name: Create GitHub Release v${{ needs.create_release_number.outputs.release-number }}
        uses: ./.github/workflows/create_github_release.yml
        with:
          release-number: ${{ needs.create_release_number.outputs.release-number }}

    release_failure:
        needs: [create_github_release, create_release_number]
        name: Release Failure Notification
        if: needs.create_github_release.result == 'failure'
        runs-on: ubuntu-latest
        steps:
        - name: Delete Release Tag
          env:
              GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              RELEASE_NUMBER: ${{ needs.create_release_number.outputs.release-number }}
          run: |
              gh api -X DELETE repos/${{ github.repository }}/git/refs/tags/${RELEASE_NUMBER}

    build-and-push-docker-image:
      name: Build and Push Docker Image
      runs-on: ubuntu-latest
      needs: [start-docker-container, create_release_number]
      permissions:
        contents: read
        packages: write

      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Log in to GitHub Container Registry
          uses: docker/login-action@v3
          with:
            registry: ghcr.io
            username: ${{ github.actor }}
            password: ${{ secrets.GITHUB_TOKEN }}
        - name: Update environment variables
          run: |
            # Check if .env.local is a directory (should not be)
            if [ -d ".env.local" ]; then
              echo ".env.local is a directory. Removing it."
              rm -rf .env.local
            fi

            # Remove existing .env.local file if it exists and is not a directory
            if [ -f ".env.local" ]; then
              echo ".env.local file exists. Removing it."
              rm .env.local
            fi

            echo 'DATABASE_ENGINE="sqlite"' >> .env.local
            echo 'DATABASE_NAME="frostfire-forge-local"' >> .env.local
            echo 'WEBSRV_PORT=80' >> .env.local
            echo 'WEBSRV_USESSL=false' >> .env.local
            echo 'WEB_SOCKET_URL="ws://localhost"' >> .env.local
            echo 'WEB_SOCKET_PORT=3000' >> .env.local
            echo 'DOMAIN="http://localhost:80"' >> .env.local
            echo 'GAME_NAME="Frostfire Forge Beta"' >> .env.local
            echo 'CACHE="memory"' >> .env.local
            echo 'VERSION="${{ needs.create_release_number.outputs.release-number }}"' >> .env.local

        - name: Build and push image
          uses: docker/build-push-action@v6
          with:
            context: .
            file: ./Dockerfile.local
            push: true
            tags: |
              ghcr.io/lillious-networks/frostfire-forge-local:${{ needs.create_release_number.outputs.release-number }}
              ghcr.io/lillious-networks/frostfire-forge-local:latest
              ghcr.io/lillious-networks/frostfire-forge-local:${{ github.sha }}