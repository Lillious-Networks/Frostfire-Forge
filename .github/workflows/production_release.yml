name: Production > Release

permissions:
  contents: write

on:
  workflow_dispatch:
  push:
    paths:
      - 'src/**'
      - 'docker-compose.prod.yml'
      - 'Dockerfile.prod'
      - '.github/workflows/production_release.yml'
    branches:
      - main

concurrency:
  group: 'production-release'
  cancel-in-progress: true

jobs:
    create_release_number:
        name: Create Release Number
        uses: ./.github/workflows/generate_release_number.yml

    build:
      name: Build v${{ needs.create_release_number.outputs.release-number }}
      needs: [create_release_number]
      runs-on: self-hosted
      environment: production
      steps:
        - name: Checkout Repository
          uses: actions/checkout@v4

        - name: Update environment variables
          run: |
            # Check if .env.production is a directory (should not be)
            if [ -d ".env.production" ]; then
              echo ".env.production is a directory. Removing it."
              rm -rf .env.production
            fi

            # Remove existing .env.production file if it exists and is not a directory
            if [ -f ".env.production" ]; then
              echo ".env.production file exists. Removing it."
              rm .env.production
            fi

            echo 'DATABASE_ENGINE=mysql' >> .env.production
            echo 'DATABASE_HOST="${{ secrets.DATABASE_HOST }}"' >> .env.production
            echo 'DATABASE_NAME="${{ secrets.DATABASE_NAME }}"' >> .env.production
            echo 'DATABASE_PASSWORD="${{ secrets.DATABASE_PASSWORD }}"' >> .env.production
            echo 'DATABASE_USER="${{ secrets.DATABASE_USER }}"' >> .env.production
            echo 'DATABASE_PORT="${{ secrets.DATABASE_PORT }}"' >> .env.production
            echo 'EMAIL_PASSWORD="${{ secrets.EMAIL_PASSWORD }}"' >> .env.production
            echo 'EMAIL_SERVICE="${{ secrets.EMAIL_SERVICE }}"' >> .env.production
            echo 'EMAIL_USER="${{ secrets.EMAIL_USER }}"' >> .env.production
            echo 'EMAIL_TEST="${{ secrets.EMAIL_TEST }}"' >> .env.production
            echo 'SESSION_KEY="${{ secrets.SESSION_KEY }}"' >> .env.production
            echo 'SQL_SSL_MODE=DISABLED' >> .env.production
            echo 'WEBSRV_PORT=80' >> .env.production
            echo 'WEBSRV_PORTSSL=443' >> .env.production
            echo 'WEBSRV_USESSL=true' >> .env.production
            echo 'GOOGLE_TRANSLATE_API_KEY="${{ secrets.GOOGLE_TRANSLATE_API_KEY }}"' >> .env.production
            echo 'OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}"' >> .env.production
            echo 'TRANSLATION_SERVICE="openai"' >> .env.production
            echo 'OPEN_AI_MODEL="gpt-4.1-nano-2025-04-14"' >> .env.production
            echo 'WEB_SOCKET_URL="wss://forge.lillious.com"' >> .env.production
            echo 'WEB_SOCKET_PORT=3000' >> .env.production
            echo 'DOMAIN="https://forge.lillious.com"' >> .env.production
            echo 'GAME_NAME="Frostfire Forge"' >> .env.production
            echo 'CACHE="memory"' >> .env.production
            echo 'REDIS_URL="redis://default:${{ secrets.REDIS_PASSWORD }}@redis:6379"' >> .env.production
            echo 'REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"' >> .env.production
            echo 'VERSION="${{ needs.create_release_number.outputs.release-number }}"' >> .env.production

        - name: Create Certificate Chain
          working-directory: src/certs
          run: |
            # Create CA Bundle using CERT_CA_BUNDLE secret
            echo "${{ secrets.CERT_CA_BUNDLE }}" > cert.ca-bundle

            # Create pem
            echo "${{ secrets.CERT_PEM }}" > cert.pem

            # Create private key
            echo "${{ secrets.CERT_PRIVATE_KEY }}" > key.pem

        - name: Build Docker Image
          run: |
            export REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
            docker compose -f docker-compose.prod.yml build

    create_release_tag:
        name: Create Release Tag
        runs-on: ubuntu-latest
        needs: [create_release_number, build]
        steps:
        - name: Create Git Tag
          env:
              GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              RELEASE_NUMBER: ${{ needs.create_release_number.outputs.release-number }}
          run: |
              SHA=$(gh api repos/${{ github.repository }}/git/ref/heads/${{ github.ref_name }} --jq '.object.sha')
              gh api repos/${{ github.repository }}/git/refs \
              -f ref="refs/tags/${RELEASE_NUMBER}" \
              -f sha="$SHA"

    create_github_release:
        needs: [create_release_number, create_release_tag]
        name: Create GitHub Release v${{ needs.create_release_number.outputs.release-number }}
        uses: ./.github/workflows/create_github_release.yml
        with:
          release-number: ${{ needs.create_release_number.outputs.release-number }}

    release_failure:
        needs: [create_github_release, create_release_number]
        name: Release Failure Notification
        if: needs.create_github_release.result == 'failure'
        runs-on: ubuntu-latest
        steps:
        - name: Delete Release Tag
          env:
              GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              RELEASE_NUMBER: ${{ needs.create_release_number.outputs.release-number }}
          run: |
              gh api -X DELETE repos/${{ github.repository }}/git/refs/tags/${RELEASE_NUMBER}

    stop-docker-containers:
      name: Stop Existing Docker Containers
      runs-on: self-hosted
      environment: production
      needs: [create_github_release]
      steps:
        - name: Stop Docker Container
          run: |
            docker compose -f docker-compose.prod.yml down || echo "No container to stop"

    start-docker-container:
      name: Start Docker Container
      runs-on: self-hosted
      environment: production
      needs: [stop-docker-containers]
      steps:
        - name: Start Docker Services
          run: |
            export REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
            docker compose -f docker-compose.prod.yml up -d

    verify-docker-container:
      name: Verify Docker Container is Running
      runs-on: self-hosted
      environment: production
      needs: [start-docker-container]
      steps:
        - name: Output Docker Logs
          run: |
            echo "Waiting 15 seconds for services to start..."
            sleep 15
            docker compose -f docker-compose.prod.yml logs --tail=50

    cleanup:
      name: Cleanup Old Docker Images
      runs-on: self-hosted
      environment: production
      needs: [start-docker-container]
      steps:
        - name: Remove Unused Docker Images
          run: |
            docker image prune -f

    build-and-push-docker-image:
      name: Build and Push Docker Image
      runs-on: ubuntu-latest
      needs: [start-docker-container, create_release_number]
      permissions:
        contents: read
        packages: write

      steps:
        - name: Checkout code
          uses: actions/checkout@v4

        - name: Log in to GitHub Container Registry
          uses: docker/login-action@v3
          with:
            registry: ghcr.io
            username: ${{ github.actor }}
            password: ${{ secrets.GITHUB_TOKEN }}
        - name: Update environment variables
          run: |
            # Check if .env.local is a directory (should not be)
            if [ -d ".env.local" ]; then
              echo ".env.local is a directory. Removing it."
              rm -rf .env.local
            fi

            # Remove existing .env.local file if it exists and is not a directory
            if [ -f ".env.local" ]; then
              echo ".env.local file exists. Removing it."
              rm .env.local
            fi

            echo 'DATABASE_ENGINE="sqlite"' >> .env.local
            echo 'DATABASE_NAME="frostfire-forge-local"' >> .env.local
            echo 'WEBSRV_PORT=80' >> .env.local
            echo 'WEBSRV_USESSL=false' >> .env.local
            echo 'WEB_SOCKET_URL="ws://localhost"' >> .env.local
            echo 'WEB_SOCKET_PORT=3000' >> .env.local
            echo 'DOMAIN="http://localhost:80"' >> .env.local
            echo 'GAME_NAME="Frostfire Forge Beta"' >> .env.local
            echo 'CACHE="memory"' >> .env.local
            echo 'VERSION="${{ needs.create_release_number.outputs.release-number }}"' >> .env.local

        - name: Build and push image
          uses: docker/build-push-action@v6
          with:
            context: .
            file: ./Dockerfile.local
            push: true
            tags: |
              ghcr.io/lillious-networks/frostfire-forge-local:${{ needs.create_release_number.outputs.release-number }}
              ghcr.io/lillious-networks/frostfire-forge-local:latest
              ghcr.io/lillious-networks/frostfire-forge-local:${{ github.sha }}