name: Development > Release

permissions:
  contents: read

on:
  push:
    paths:
      - 'src/**'
      - 'docker-compose.dev.yml'
      - 'Dockerfile.dev'
      - '.github/workflows/development_release.yml'
    branches:
      - development

  workflow_dispatch:

concurrency:
  group: 'development-release'
  cancel-in-progress: true

jobs:
  build:
    name: Build Development
    runs-on: self-hosted
    environment: development
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Update environment variables
        run: |
          # Check if .env.development is a directory (should not be)
          if [ -d ".env.development" ]; then
            echo ".env.development is a directory. Removing it."
            rm -rf .env.development
          fi

          # Remove existing .env.development file if it exists and is not a directory
          if [ -f ".env.development" ]; then
            echo ".env.development file exists. Removing it."
            rm .env.development
          fi

          echo 'DATABASE_ENGINE="sqlite"' >> .env.development
          echo 'DATABASE_NAME="frostfire-forge-dev"' >> .env.development
          echo 'WEBSRV_PORT=8080' >> .env.development
          echo 'WEBSRV_USESSL=false' >> .env.development
          echo 'WEB_SOCKET_URL="ws://forge.lillious.com"' >> .env.development
          echo 'WEB_SOCKET_PORT=3001' >> .env.development
          echo 'DOMAIN="http://forge.lillious.com:8080"' >> .env.development
          echo 'GAME_NAME="Frostfire Forge Beta"' >> .env.development
          echo 'CACHE="redis"' >> .env.development
          echo 'REDIS_URL="redis://default:development@redis-dev:6380"' >> .env.development
          echo 'REDIS_PASSWORD="development"' >> .env.development
          echo 'VERSION="${{ github.run_number }}-development"' >> .env.development

      - name: Build Docker Image
        run: |
          docker compose -f docker-compose.dev.yml build

  backup-docker-images:
    name: Backup Current Docker Images
    runs-on: self-hosted
    environment: development
    needs: [build]
    steps:
      - name: Tag current images as backup
        run: |
          # Get list of running containers and their images
          RUNNING_IMAGES=$(docker compose -f docker-compose.dev.yml ps --format json | jq -r '.Image' 2>/dev/null || echo "")

          if [ -n "$RUNNING_IMAGES" ]; then
            echo "Backing up current Docker images..."
            # Remove duplicates and filter out SHA256 hashes
            UNIQUE_IMAGES=$(echo "$RUNNING_IMAGES" | sort -u | grep -v "^sha256:")

            while IFS= read -r image; do
              if [ -n "$image" ] && [ "$image" != "sha256:"* ]; then
                # Tag each running image with a backup suffix
                echo "Tagging $image as ${image}-backup"
                docker tag "$image" "${image}-backup" || echo "Failed to tag $image, might not exist"
              fi
            done <<< "$UNIQUE_IMAGES"
          else
            echo "No running containers found to backup"
          fi

  stop-docker-container:
    name: Stop Docker Container
    runs-on: self-hosted
    environment: development
    needs: [backup-docker-images]
    steps:
      - name: Stop Docker Container
        run: |
          docker compose -f docker-compose.dev.yml down || echo "No container to stop"

  start-docker-container:
    name: Start Docker Container
    runs-on: self-hosted
    environment: development
    needs: [stop-docker-container]
    steps:
      - name: Start Docker Services
        run: |
          docker compose -f docker-compose.dev.yml up -d

  verify-docker-container:
    name: Verify Docker Container is Running
    runs-on: self-hosted
    environment: development
    needs: [start-docker-container]
    outputs:
      status: ${{ steps.verify.outcome }}
    steps:
      - name: Wait for services and check logs
        id: verify
        continue-on-error: true
        run: |
          echo "Waiting 15 seconds for services to start..."
          sleep 15

          echo "Fetching Docker logs..."
          LOGS=$(docker compose -f docker-compose.dev.yml logs --tail=50)

          echo "$LOGS"

          if echo "$LOGS" | grep -q "Webserver started"; then
            echo "✅ Webserver started successfully"
            exit 0
          else
            echo "❌ Webserver did NOT start"
            exit 1
          fi

      - name: Check verification result
        if: steps.verify.outcome == 'failure'
        run: |
          echo "Verification failed, triggering rollback..."
          exit 1

  rollback:
    name: Rollback to Previous Docker Images
    runs-on: self-hosted
    environment: development
    needs: [verify-docker-container]
    if: failure() && needs.verify-docker-container.outputs.status == 'failure'
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Stop failed containers
        run: |
          echo "Stopping failed Docker containers..."
          docker compose -f docker-compose.dev.yml down || echo "No containers to stop"

      - name: Restore backup images
        run: |
          echo "Restoring backup Docker images..."

          # Find all backup images
          BACKUP_IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -- "-backup$" || echo "")

          if [ -n "$BACKUP_IMAGES" ]; then
            while IFS= read -r backup_image; do
              if [ -n "$backup_image" ]; then
                # Remove -backup suffix to get original image name
                original_image="${backup_image%-backup}"
                echo "Restoring $backup_image to $original_image"

                # Remove the new (failed) image if it exists
                docker rmi "$original_image" 2>/dev/null || echo "No new image to remove"

                # Re-tag backup image to original name
                docker tag "$backup_image" "$original_image"
              fi
            done <<< "$BACKUP_IMAGES"
          else
            echo "No backup images found to restore"
            exit 1
          fi

      - name: Start containers with backup images
        run: |
          echo "Starting Docker containers with backup images..."
          docker compose -f docker-compose.dev.yml up -d

      - name: Verify rollback
        run: |
          echo "Waiting 15 seconds for services to start..."
          sleep 15

          echo "Fetching Docker logs..."
          LOGS=$(docker compose -f docker-compose.dev.yml logs --tail=50)

          echo "$LOGS"

          if echo "$LOGS" | grep -q "Webserver started"; then
            echo "✅ Rollback successful - Previous version is running"
          else
            echo "❌ Rollback failed - Manual intervention required"
            exit 1
          fi

  cleanup:
    name: Cleanup Old Docker Images
    runs-on: self-hosted
    environment: development
    needs: [start-docker-container, verify-docker-container]
    if: success() && needs.verify-docker-container.outputs.status == 'success'
    steps:
      - name: Remove Backup and Unused Docker Images
        run: |
          echo "Removing backup Docker images..."
          # Remove all backup images
          BACKUP_IMAGES=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -- "-backup$" || echo "")

          if [ -n "$BACKUP_IMAGES" ]; then
            while IFS= read -r backup_image; do
              if [ -n "$backup_image" ]; then
                echo "Removing backup image: $backup_image"
                docker rmi "$backup_image" || echo "Failed to remove $backup_image"
              fi
            done <<< "$BACKUP_IMAGES"
          else
            echo "No backup images found"
          fi

          echo "Removing unused Docker images..."
          docker image prune -f